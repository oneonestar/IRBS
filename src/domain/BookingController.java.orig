import java.util.*;
import java.text.SimpleDateFormat;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import java.security.MessageDigest;

/**
 * The main controller to handle all the booking and querying.
 * This class is a singleton class.
 */
public class BookingController {
	private static BookingController settings = null;
	private List<Timeslot> bookingRecords;
	private List<Room> rooms;
	private List<User> users;
	private Map<User, String> hashedPasswordRecords;

	/**
	 * This function provide the access to the singleton instance.
	 * @return the singleton instance of the BookingController.
	 */
	public static BookingController getInstance() {
		if (settings  == null) {
			settings = new BookingController();
		}
		return settings;
	}

	/**
	* Add a new booking into the database. Do not provide checking on data integrity.
	* @param user user who is making this booking.
	* @param slot the room and the timeslot to be booked.
	* @return true if nothing the adding is successful.
	*/
	public boolean addBooking(User user, Timeslot timeslot) {
		if (user == null || timeslot == null)
			return false;
		Booking newBooking = new Booking(user, timeslot, Integer.toString(bookingRecords.size()));
		bookingRecords.add(newBooking);
		return true;
	}
	/**
	 * Constructor of the BookingController. Responsible for the initialization
	 * of the private members and load the data into the program.
	 */
	public BookingController() {
		rooms = new ArrayList<Room>();
		users = new ArrayList<User>();
		bookingRecords = new ArrayList<Timeslot>();
		hashedPasswordRecords = new HashMap<User, String>();
		//The order of loading is important. There are dependency between the data.
		loadRoomData(Settings.getInstance().roomRecordFile);
		loadUserData(Settings.getInstance().userRecordFile);
		loadBookingData(Settings.getInstance().bookingRecordFile);
	}
	/**
	 * Load the room data from the file.
	 * Schema: String roomNumber (primary key), String roomType, String roomLocation
	 * @param filename the txt file which stored the data.
	 * @return true if the loading is successful.
	 */
	public boolean loadRoomData(String filename) {
		Path path = Paths.get("", filename);
		Charset charset = Charset.forName("ISO-8859-1");
		try {
			List<String> lines = Files.readAllLines(path, charset);

			for (String line : lines) {
				StringTokenizer st = new StringTokenizer(line, ";");
				rooms.add(new Room(st.nextToken(), st.nextToken(), st.nextToken()));
			}
		} catch (IOException e) {
			System.out.println(e);
		}
		return true;
	}
	/**
	 * Load the User data from the file.
	 * Schema: String userID (primary key), String firstName, String lastName, String password
	 * @param filename the txt file which stored the data.
	 * @return true if the loading is successful.
	 */
	public boolean loadUserData(String filename) {
		Path path = Paths.get("", filename);
		Charset charset = Charset.forName("ISO-8859-1");
		try {
			List<String> lines = Files.readAllLines(path, charset);

			for (String line : lines) {
				StringTokenizer st = new StringTokenizer(line, ";");
				String staffID = st.nextToken();
				String firstName = st.nextToken();
				String lastName = st.nextToken();
				String hashedPassword = st.nextToken();
				User user = new User(staffID, firstName, lastName);
				hashedPasswordRecords.put(user, hashedPassword);
				users.add(user);
			}
		} catch (Exception e) {
			System.out.println(e);
		}
		return true;
	}
	/**
	 * Load the booking data from the file.
	 * Schema: String bookingID (primary key), String userID, String RoomID,
	 *         Date Timeslot
	 * @param filename the txt file which stored the data.
	 * @return true if the loading is successful.
	 */
	public boolean loadBookingData(String filename) {
		Path path = Paths.get("", filename);
		Charset charset = Charset.forName("ISO-8859-1");
		try {
			List<String> lines = Files.readAllLines(path, charset);

			for (String line : lines) {
				StringTokenizer st = new StringTokenizer(line, ";");

				String bookingID = st.nextToken();
				String staffID = st.nextToken();
				String room = st.nextToken();
				String timeString = st.nextToken();


				Calendar calendar = Calendar.getInstance();
				SimpleDateFormat sdf = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy", new  Locale("en", "US"));
				try {
					Date date = sdf.parse(timeString);
					calendar.setTime(date);
					calendar.set(Calendar.MILLISECOND, 0);
				} catch (Exception e) {
				}
				Room room = searchRoom(room);
				User user = searchUser(staffID);
				if (room == null || user == null) {
					System.out.print("Database corrupted!");
					return false;
				}
				Timeslot timeslot = new Timeslot(room, calendar);
				bookingRecords.add(new Booking(user, timeslot, Integer.toString(bookingRecords.size())));
			}
		} catch (IOException e) {
			System.out.println(e);
		}
		return true;
	}
	/**
	 * Authenticate the login request by comparing the staffID and password
	 * and the entities in the database.
	 * @param staffID the staffID should be unique.
	 * @param password the password that matches the staffID.
	 * @return true if the entity exist in database, otherwise return false.
	 */
	public User authenticate(String staffID, String password) {
		StringBuffer sb = new StringBuffer();
		try {
			MessageDigest md = MessageDigest.getInstance("SHA-256");
			md.update(password.getBytes("UTF-8"));
			byte[] mdbytes = md.digest();

			for (int i = 0; i < mdbytes.length; i++) {
				sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
			}
		} catch (Exception e) {
			System.out.println(e);
		}

		String hashedPassword = sb.toString();
		System.out.println(hashedPassword);
		for (User user : users) {
			System.out.println(hashedPasswordRecords.get(user));
			if (user.getStaffID().equals(staffID) && hashedPasswordRecords.get(user).equals(hashedPassword))
				return user;
		}
		return null;
	}

	/**
	 * Return all the type of rooms that that exist in the room list.
	 * @return a set of room types (eg. "Computer Labs", "Classroom").
	 */
	public Set<String> queueRoomTypes() {
		Set<String> roomSet = new HashSet<>();
		for (Room room : rooms) {
			roomSet.add(room.getRoomType());
		}
		return roomSet;
	}

	/**
	 * Return all the current booking records of the user.
	 * @param user which user booked the rooms.
	 * @return a list of slots which contains the Room id, timeslot, etc.
	 */
	public List<Booking> queueCurrentBookings(User user) {
		List<Booking> currentBookings = new ArrayList<Booking>();
		for (Booking booking : bookingRecords) {
			if (booking.user.equals(user) && booking.time.compareTo(Calendar.getInstance()) >= 0)
				currentBookings.add(slot);
		}
		return currentBookings;
	}

	private Room searchRoom(String roomNumber) {
		for (Room room : rooms) {
			if (room.getRoomNumber().equals(roomNumber))
				return room;
		}
		return null;
	}

	private User searchUser(String staffID) {
		for (User user : users) {
			if (user.getStaffID().equals(staffID))
				return user;
		}
		return null;
	}
	/**
	 * Return all the current booking records of the user.
	 * @param roomType a string that specified the room type. Should
	 *        be match a value returned by queueRoomTypes().
	 * @param date search the timeslots in which date.
	 * @return a list of slots which contains all the available timeslots in that date.
	 */
	public List<Timeslot> queueAvailableSlot(String roomType, Calendar date) {
		List<Timeslot> availableSlot = new ArrayList<Timeslot>();
		date.set(Calendar.HOUR_OF_DAY, 0);
		date.set(Calendar.MINUTE, 0);
		date.set(Calendar.SECOND, 0);
		date.set(Calendar.MILLISECOND, 0);
		Calendar start = (Calendar)date.clone();
		Calendar end = (Calendar)date.clone();

		start.set(Calendar.HOUR_OF_DAY, Settings.getInstance().dayStartTime.get(Calendar.HOUR_OF_DAY));
		end.set(Calendar.HOUR_OF_DAY, Settings.getInstance().dayEndTime.get(Calendar.HOUR_OF_DAY));

		//generate all timeslot for the rooms
		for (Room room : rooms) {
			if (room.getRoomType().equals(roomType)) {
				Calendar tempCal = (Calendar)start.clone();
				while (tempCal.compareTo(end) <= 0) {
					if (tempCal.compareTo(Calendar.getInstance()) >= 0) {
						availableSlot.add(new Timeslot(room, tempCal));
						tempCal = (Calendar)tempCal.clone();
					}
					tempCal.add(Calendar.HOUR_OF_DAY, 1);
				}
			}
		}
		//remove the booked timeslot
		for (Iterator<Timeslot> iterator = availableSlot.iterator(); iterator.hasNext(); ) {
			Timeslot slot = iterator.next();
			for (Timeslot bookedslot : bookingRecords) {
				if (bookedslot.room.getRoomNumber().equals(slot.room.getRoomNumber()) && bookedslot.time.compareTo(slot.time) == 0) {
					iterator.remove();
					break;
				}
			}
		}
		return availableSlot;
	}
}

/**
 * Contain all the global settings (eg. the maximum booking
 * count for each individual...).
 * This class is a singleton class.
 */
//public final class Settings {
class Settings {
	private static Settings settings = null;
	/**
	 * This function provide the access to the singleton object.
	 * @return the singleton object of the BookingController.
	 */
	public static synchronized Settings getInstance() {
		if (settings  == null) {
			settings = new Settings();
		}
		return settings;
	}

	public final int maxBooking = 5;
	public final String roomRecordFile = "rooms.txt";
	public final String userRecordFile = "users.txt";
	public final String bookingRecordFile = "booking.txt";
	public final Calendar dayStartTime;
	public final Calendar dayEndTime;
	
	/**
	 * Init the complex data type.
	 */
	private Settings() {
		//0800
		dayStartTime = Calendar.getInstance();
		dayStartTime.set(Calendar.HOUR_OF_DAY, 8);
		dayStartTime.set(Calendar.MINUTE, 0);
		dayStartTime.set(Calendar.SECOND, 0);
		dayStartTime.set(Calendar.MILLISECOND, 0);

		//1700
		dayEndTime = Calendar.getInstance();
		dayEndTime.set(Calendar.HOUR_OF_DAY, 17);
		dayEndTime.set(Calendar.MINUTE, 0);
		dayEndTime.set(Calendar.SECOND, 0);
		dayEndTime.set(Calendar.MILLISECOND, 0);
	}
}